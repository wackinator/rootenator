import path from "node:path";
import type { WackyConfig } from "./index.js";
import { mixHexColors } from "./tools/colorGeneration/colorMix.js";

export function generateCss(
  config: WackyConfig,
  configDir: string,
): { generated: string; path: string } {
  const lines = [
    "// ## // ## // ## // ##\n",
    "// This file is generated by @wacky/rootenator; plz dont edit i worked hard (not really) on this.\n",
    "// ## // ## // ## // ##\n\n",
  ];

  const sizes = [];
  const colors = [];
  const darkColors = [];

  const targetFolder = config.exportPath
    ? path.resolve(configDir, config.exportPath)
    : configDir;

  const finalPath = path.join(
    targetFolder,
    config.scss?.enable
      ? config.scss?.underscore
        ? "_rootenator.scss"
        : "rootenator.scss"
      : "rootenator.css",
  );

  if (config.sizingOptions) {
    const prefix = config.sizingOptions.prefix || "s";
    const unit = config.sizingOptions.sizingUnit || "rem";

    if (config.sizingOptions.sizes) {
      appendVariables(sizes, config.sizingOptions.sizes, prefix, unit);
    }
  }

  if (config.colorOptions) {
    const prefix = config.colorOptions.prefix || "cl-";

    if (config.colorOptions.colors) {
      appendVariables(colors, config.colorOptions.colors, prefix);
    }

    if (config.colorOptions.darks) {
      appendVariables(darkColors, config.colorOptions.darks, prefix);
    }

    if (config.colorOptions.mixColors) {
      if (config.colorOptions.mixColors.length !== 0) {
        for (const mixStr of config.colorOptions.mixColors) {
          const parts = mixStr.split(">");
          const mode = Number(parts[0]);
          const steps = 100;

          // Mode 1: 1>color1:color2:weight>name (takes from root colors [not dark mode])
          if (mode === 1) {
            const [color1, color2, weightStr] = parts[1].split(":");
            const name = parts[2];
            const weight = parseFloat(weightStr);

            const mixed = mixHexColors(
              config.colorOptions.colors[color1] || "#000000",
              config.colorOptions.colors[color2] || "#000000",
              weight,
              steps,
            );
            appendVariables(colors, { [name]: mixed }, prefix);
          }
          // Mode 2:  2>lightColor1:lightColor2:weight>darkColor1:darkColor2:weight>name (aware of dark mode)
          else if (mode === 2) {
            const [lightPart, darkPart, name] = parts.slice(1);
            const [l1, l2, lw] = lightPart.split(":");
            const [d1, d2, dw] = darkPart.split(":");
            const lightMix = mixHexColors(
              config.colorOptions.colors[l1] || "#000000",
              config.colorOptions.colors[l2] || "#000000",
              parseFloat(lw),
              steps,
            );
            const darkMix = mixHexColors(
              config.colorOptions.darks[d1] || "#000000",
              config.colorOptions.darks[d2] || "#000000",
              parseFloat(dw),
              steps,
            );
            appendVariables(colors, { [name]: lightMix }, prefix);
            appendVariables(darkColors, { [name]: darkMix }, prefix);
          }
        }
      }
    }

    function generateRoots() {
      lines.push(":root {");
      if (sizes.length > 0) {
        lines.push("\n/* Sizing Variables */\n");
        lines.push(...sizes);
      }
      if (colors.length > 0) {
        lines.push("\n/* Color Variables */\n");
        lines.push(...colors);
      }
      lines.push("}");
    }
    generateRoots();

    if (colors.length > 0) {
      lines.push("\n/* Forced Light Mode */\n[data-theme='light'] {\n");
      lines.push(...colors);
      lines.push("}");
    }

    if (darkColors.length > 0) {
      lines.push(
        "\n/* Dark Mode Preference */\n@media (prefers-color-scheme: dark) {\n  :root {\n",
      );
      lines.push(...darkColors);
      lines.push("  }\n}");

      lines.push("\n/* Forced Dark Mode */\n[data-theme='dark'] {\n");
      lines.push(...darkColors);
      lines.push("}");
    }
  }

  return { generated: lines.join(""), path: finalPath };
}

function appendVariables(
  lines: string[],
  obj: Record<string, string>,
  prefix: string,
  unit = "",
) {
  for (const [key, value] of Object.entries(obj)) {
    lines.push(`  --${prefix}${key}: ${value}${unit};\n`);
  }
}
